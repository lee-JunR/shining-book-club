# 6장. 동시성 — 데이터가 꼬이기 전에 잡아야 한다

## 요약 정리

### 1) 동시성과 잠금
동시에 여러 스레드(또는 프로세스)가 같은 자원에 접근하면 값이 꼬이는 문제가 발생한다.  
이를 막기 위해 잠금(lock)을 사용하거나, 원자적 타입/동시성 컬렉션 같은 안전한 구조를 사용한다.

---

## 2) DB와 동시성

### ■ 선점(비관적) 잠금
- 먼저 접근한 트랜잭션이 자원을 잠그고 다른 트랜잭션은 대기한다.
- 여러 서버/프로세스가 접근할 경우 **분산잠금(예: Redis)** 을 사용한다.

### ■ 비선점(낙관적) 잠금
- 잠금을 걸지 않고, 읽은 시점의 데이터와 수정 시점의 데이터가 같은지 비교하여 충돌 여부를 판단한다.
- 보통 **정수 버전 컬럼(version)** 으로 충돌을 감지한다.

### ■ 외부 연동과 트랜잭션
- 트랜잭션 내부에서 외부 API를 호출해야 한다면 낙관적 잠금보다 선점 잠금이 안전하다.

### ■ 증분 쿼리 문제
update SUBJECT set joinCount = joinCount + 1 where id = ?
- 일부 DB에서 이 연산이 **원자적이지 않을 수도 있으므로**, 반드시 DB 수준에서 원자성 보장 여부를 확인해야 한다.

---

## 3) 잠금 사용 시 주의사항

### ■ 잠금 해제는 finally
lock.lock();  
try {  
...  
} finally {  
lock.unlock();  
}

### ■ 교착 상태(deadlock) 예방
- 잠금 대기 시간 제한 설정
- 항상 같은 순서로 잠금을 획득

### ■ 라이브락(livelock)
계속 움직이지만 실제 진전이 없는 상태.  
우선순위를 조정해 해결한다.

### ■ 기아(starvation)
특정 스레드가 자원을 계속 얻지 못해 실행되지 못하는 상태.  
우선순위를 높이거나 자원 독점 시간을 제한하여 방지한다.

---

## 4) 단일 스레드 처리 전략
- 단일 스레드만 자원에 접근하게 하면 동시성 문제가 원천적으로 사라진다.
- 단점: 구조가 복잡해질 수 있음.
- 성능은 상황에 따라 다름
    - 임계 영역이 짧고 스레드 수가 적다면 잠금 방식이 유리
    - 임계 영역이 길고 작업량이 많다면 단일 스레드 + 큐 방식이 더 나을 수도 있다.
