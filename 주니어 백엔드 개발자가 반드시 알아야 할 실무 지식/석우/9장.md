# 9장 정리 -

## 9장 최소한 알고 있어야 할 서버 지식.

- OS 계정과 권한
- 프로세스
- 디스크 용량
- 파일 디스크립터 제한
- 시간 동기화
- 크론을 이용한 스케줄링
- 별칭
- 네트워크 정보 확인

## ** 최소한 알고 있어야 할 서버 지식 지식 정리 **

### OS 계정과 권한

백엔드 개발자는 리눅스의 기본적인 계정과 권한 관리를 이해할 필요가 있다.

- root 계정 및 권한 문제 : root 계정은 모든 권한을 가진 관리자 계정이므로 인프라 담당자에게만 접근 권한을 제한하는 것이 일반적이다.

- 권한 확인 및 변경 : 파일이나 디렉터리에 대한 권한은 ls -l 명령어로 확인할 수 있으며(r=읽기, w=쓰기, x=실행)이 있고 권한 변경 시에는 chmod 명령어를 사용하여 숫자 또는 기호방식으로 설정해야 한다. 보안 취약성을 높이는 chmod 777 사용은 피해야 한다.

- sudo 사용 : 개발자가 root 권한이 필요한 작업을 수행해야 할 때 sudo 명령어를 사용하면 일반 계정으로도 root의 권한으로 프로그램을 실행할 수 있게 설정하여 업무 효율을 높일 수 있다. 또한 sudoers 파일에 특정 명령어에 대해서만 실행 권한을 부여하여 보안을 유지할 수도 있다.

### 프로세스

서버 프로세스의 정상 동작 여부 확인 및 비정상 종료 시 대처 능력이 필요

- 프로세스 확인 : 실행 중인 프로세스의 소유자, 프로세스 ID (PID), 명령행 인자 등의 정보를 확인하려면 ps qux or ps -eaf 명령어를 사용하고 실시간 CPU 및 메모리 사용량 확인에는 top 이나 htop를 사용한다.

- 프로세스 종료 : 프로세스 ID를 확인 후 kill 명령어를 사용해서 종료한다.

  - kill -15 (SIGTERM): 프로세스가 정리 작업을 수행할 시간을 주면서 종료를 요청(기본값)
  - kill -9 (SIGKILL): 프로세스를 강제로 종료하며, 프로그램이 정리 작업을 수행할 수 없으므로 -15로 여러 차례 시도해도 종료되지 않을 때 사용

- 백그라운드 실행 : 톰캣 같은 서버 프로그램은 백그라운드 프로세스로 실행된다.
  명령어 뒤에 &를 붙여 백그라운드로 실행하며 터미널과의 연결이 끊겨도 프로세스가 계속 실행되도록 하려면 nohup과 & 함께 사용한다.

### 디스크 용량

디스크 용량이 가득 차서 OS가 구동되지 않는 문제를 방지하기 위해 용량 관리가 중요하다.

- 용량 확인 : df -h 명령어로 파티션별 디스크 사용률을 확인할 수 있으며, du -sh 명령어로 특정 디렉터리나 파일이 차지하는 용량을 확인할 수 있다.
- 로그 관리 : 로그 파일은 디스크 용량을 지속적으로 증가시키는 주된 요인이므로, 로그 로테이션을 통해 로그 파일을 일정 단위로 자르거나, 오래된 로그 파일을 삭제하거나 압축해서 보관한다.
- 파일 삭제 (임시방편) : 디스크 용량이 부족하여 긴급 조치가 필요할 때, cp /dev/null out.log와 같은 널 카피를 사용하여 로그 파일의 크기를 0으로 만들어 용량을 확보할 수 있다. (기존 로그 유실됨)

### 파일 디스크립터 제한

프로세스는 데이터 입출력 시 OS로부터 파일 디스크립터(FD)를 할당받는데 이 개수 제한에 도달하면 소켓 생성 실패와 같은 오류가 발생한다.

- 문제 방지 : 트래픽 증가에 맞춰 파일 디스크립터 개수 제한을 미리 확인하고 늘려야 한다.
- 제한 확인 : ulimit -a 명령어나 ulimit -n 명령어를 사용해서 현재 사용자의 FD 제한(open files 값)을 확인할 수 있다.
- 설정 변경 : 시스템 기본값을 변경하려면 /etc/security/limits.conf 파일이나 systemd 설정을 통해 nofile 값을 수정할 수 있다.

### 시간 동기화

서버를 운영할 때 서버 시간과 실제 시간의 오차로 인해 데이터 생성 시간이 틀어지는 등 문제가 발생할 수 있다.

- 필요성 : 서버가 여러 대일 경우 각 서버의 시간이 제각각이면 카산드라 클러스터와 같이 시간을 중요하게 여기는 기능에서 문제가 발생할 수 있다.
  또한 결제 승인 API처럼 요청 시점의 시간과 관련된 검증 로직에서도 문제가 발생할 수 있다.
- 해결책 : chrony나 ntp 같은 서비스를 이용해서 주기적으로 서버 시간을 동기화해야 한다.

### 크론을 이용한 스케줄링

일정 시간마다 반복해야 하는 작업(예: 로그 파일 삭제, DB 백업)을 크론(cron)을 이용해 스케줄링 한다.

- 크론탭 설정 : crontab -e 명령어를 사용하여 OS 계정별로 크론탭(crontab) 작업을 정의
- 문법 : 분, 시, 월의 일, 월, 요일의 5개 시간 패턴 뒤에 실행할 명령어를 지정합니다. \*은 해당 시간 단위의 매 시점을 의미
- 로그 : 크론탭으로 실행한 명령어의 콘솔 출력 내용은 리디렉션(> file.log 2>&1)을 사용해 별도 파일에 남겨야 추후 문제 분석에 활용할 수 있다.

### 별칭

자주 사용하는 긴 명령어를 짧은 별칭(alias)으로 등록하여 사용상의 번거로움을 줄일 수 있다.

- 등록 : alias 별칭='명령어' 형식으로 설정하며, 영구적으로 적용하려면 .bashrc 파일과 같은 셸 구성 파일에 등록해야 한다.

### 네트워크 정보 확인

네트워크 관련 문제가 발생했을 때 신속하게 원인을 파악하기 위해 기본 네트워크 명령어를 알아야 한다.

- IP 주소 확인 : ifconfig 명령어를 사용하면 서버의 IP 주소(inet), IPv6 주소(inet6) 등의 정보를 확인할 수 있다.
- 연결 확인 : nc (netcat) 명령어를 사용하여 특정 서버의 포트로 연결이 잘 되는지 확인할 수 있다. (nc -z -v 호스트 포트)
- 포트 사용 확인 : netstat 명령어를 사용하여 현재 사용 중인 소켓의 IP와 포트를 확인할 수 있으며, 서버 포트 충돌 여부를 확인할 때 유용하다. (netstat -lputn)

#### 결론

9장에서 다루는 서버 지식들은 백엔드 개발자에게 코드를 제외한 영역에서 발생하는 문제를 스스로 진단하고 해결할 수 있는 기본적인 역량을 제공하는 내용이다.

대규모 조직에서는 인프라와 개발 팀이 분리되어 있을지라도, 서버 OS(운영체제)에 대한 기초 지식이 부족하면 애플리케이션 문제인지 OS/인프라 문제인지 구분하는 데 어려움을 겪고,
사소한 설정 실수(예: 권한, 파일 디스크립터, 시간 동기화)가 서비스 전체에 영향을 미치는 심각한 문제로 이어지는 것을 막을 수 없다.

따라서 주니어 개발자는 이 장에서 제시된 OS 계정 관리, 프로세스 제어, 디스크 및 리소스 제한 관리, 스케줄링, 네트워크 정보 확인과 같은 핵심 서버 관리 기초 지식을 최소한으로 숙지한다고 생각한다.
