# 6-2장 정리

## 6-2장 동시성, 데이터가 꼬이기 전에 잡아야 한다.

- DB와 동시성: 선점 잠금과 비선점 잠금
- 잠금 주의 사항

### ** 동시성, 데이터가 꼬이기 전에 잡아야 한다 정리**

## 1. DB와 동시성 및 잠금의 필요성

```
DB 트랜잭션은 데이터 처리 과정에서 발생하는 다양한 동시성 문제를 해결해 주는 유용한 기능이지만 모든 동시성 문제를 해결할 수는 없습니다. 특히 여러 스레드나 프로세스가 동시에 DB 데이터를 수정할 때 데이터 일관성에 문제가 생길 수 있으며 이를 방지하기 위해 DB 잠금 기능을 활용해야 한다.

DB에서 발생하는 동시성 문제를 해결하기 위한 대표적인 잠금 기법으로는 선점 잠금(비관적 잠금)과 비선점 잠금(낙관적 잠금)이 있다.
```

## 2. 선점 잠금 (Preemptive/비관적 잠금)

```
선점 잠금(비관적 잠금)은 명시적인 잠금 기법이며 데이터에 먼저 접근한 트랜잭션이 잠금을 획득하는 방식이다.

동일한 레코드에 대해 한 번에 하나의 트랜잭션만 접근하도록 제어하고 한 트랜잭션이 잠금을 획득하면 다른 트랜잭션은 잠금이 해제될 때까지 대기해야 한다.

트랜잭션이 종료될 때 (커밋 또는 롤백) 잠금이 반환하고 데이터 변경 과정에 외부 시스템 연동이 포함되어 트랜잭션 범위가 길어질 경우 비선점 잠금보다 선점 잠금을 고려하는 것이 좋다.

다수가 데이터 변경을 시도할 때 성공 가능성이 낮다고 비관적으로 판단하여 한 번에 1개 클라이언트만 접근하도록 배타적 잠금을 사용하기 때문이다.
```

## 3. 비선점 잠금 (Non-preemptive/낙관적 잠금)

```
비선점 잠금(낙관적 잠금)은 명시적으로 잠금을 사용하지 않는 방식이며 데이터를 조회한 시점의 값과 수정하려는 시점의 값이 같은지 비교하는 방식으로 동시성 문제를 처리한다.

일반적으로 정수 타입의 버전 칼럼을 사용하고 SELECT 시 version을 함께 조회한 뒤 UPDATE 쿼리 실행 시 version 칼럼을 1 증가시키고 WHERE 절에 조회한 version 값과 같은지 비교하는 조건을 추가한다.

UPDATE 결과 변경된 행 개수가 0이면 실패한 것으로 간주하여 롤백하고 (다른 트랜잭션이 이미 변경했기 때문) 0보다 크면 데이터 변경에 성공한 것으로 간주한다.

잠금을 구하기 위한 대기 과정이 없어 실패할 경우 사용자에게 더 빠르게 결과를 응답할 수 있다.

동시 변경 충돌 가능성이 낮다고 낙관적으로 판단하여 배타적 잠금 없이 값 비교를 통해 문제를 해결한다.
```

## 4. 증분 쿼리 (Incremental Query)

```
update SUBJECT set joinCount = joinCount + 1 where id = ?와 같이 값을 갱신하는 증분 쿼리를 사용하면 잠금을 사용하지 않으면서도 동시성 문제를 해결할 수 있는 경우가 있다.

DB는 joinCount = joinCount + 1과 같은 연산을 원자적 연산으로 처리하며 동일 데이터에 대한 원자적 연산이 동시에 실행될 경우 이를 순차적으로 실행하여 데이터 누락 문제가 발생하지 않는다.

증분 쿼리를 사용할 때는 사용하는 DB에서 원자적으로 처리되는지 반드시 검증해야 한다.
```

## 5. 잠금 사용 시 주의 사항

```
잠금을 사용할 때는 동시성 문제 외에 교착 상태(Deadlock)나 무한 대기 같은 또 다른 문제가 발생할 수 있으므로 다음 사항에 주의해야 하는데 잠금을 획득했다면 반드시 잠금을 해제해야 하고 잠금을 해제하지 않으면 잠금을 시도하는 스레드가 무한정 대기한다.

습관적으로 try-finally 형태의 코드 구조를 사용하고 finally 블록에서 잠금 해제 코드(lock.unlock())를 작성하여 잠금이 무조건 해제되도록 해야 한다.

대기 시간 지정으로 동시 접근으로 인해 대기 시간이 길어지는 것을 막기 위해 tryLock(5, TimeUnit.SECONDS)처럼 잠금 획득 대기 시간을 지정하는 것이 좋다.

대기 시간이 길어지면 사용자에게 불안감을 줄 수 있으므로 일정 시간 내에 잠금 획득에 실패하면 사용자에게 빠르게 실패 응답을 주는 것이 도움이 된다.

2개 이상의 자원 잠금을 획득하는 코드 구조는 교착 상태(서로 무한히 기다리는 상황)에 빠지기 쉽고 교착 상태 해소를 위해 잠금 대기 시간을 제한하거나 지정한 순서대로 잠금을 획득하는 방식(예: 정렬 순서)으로 구현하여 교착 상태 발생을 줄일 수 있다.
```

#### 결론

DB 환경에서 동시성 문제 해결을 위해 선점 잠금과 비선점 잠금은 필수적인 기법이다.

선점 잠금(비관적 잠금)은 데이터 충돌이 빈번할 것으로 예상될 때 트랜잭션의 순차적 실행을 보장하여 데이터 일관성을 강력하게 유지하지만 잠금 대기로 인해 응답 시간이 길어질 수 있습니다.

반면 비선점 잠금(낙관적 잠금)은 충돌 가능성이 낮을 때 버전 비교를 통해 빠르게 처리하며 충돌 발생 시 롤백하지만 대기 시간을 줄여줍니다.

따라서 서비스의 특성(데이터 충돌 빈도, 외부 연동 포함 여부, 응답 속도 민감도)을 고려하여 적절한 잠금 방식을 선택해야 한다.

또한 잠금 사용 시에는 잠금 해제 코드의 누락 방지, 대기 시간 설정, 그리고 교착 상태 방지를 위한 순서 지정 등의 주의 사항을 철저히 준수해야 서비스의 안정성을 확보할 수 있다.

이는 마치 도로 교통 상황에서 상황에 따라 신호등(선점 잠금)을 쓸지 양보(비선점 잠금)를 통해 빠르게 처리할지 결정하고 모든 운전자가 기본적인 안전 수칙(주의 사항)을 지켜야 사고 없이 시스템이 원활하게 운영되는 것과 같다.
