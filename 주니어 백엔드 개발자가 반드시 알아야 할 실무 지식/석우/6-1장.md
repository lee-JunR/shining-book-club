# 6-1장 정리

## 6-1장 동시성, 데이터가 꼬이기 전에 잡아야 한다.

- 동시성 문제
- 잠금을 이용한 동시 접근 제어
- 원자적 타입과 동시성 지원 컬렉션

### ** 동시성, 데이터가 꼬이기 전에 잡아야 한다 정리**

왜 동시성 제어가 필요한가?

- 서버는 기본적으로 여러 스레드가 동시에 실행되는 환경이다.
- 공유 자원(변수, 컬렉션, DB 데이터 등)에 여러 스레드가 동시에 접근하면 결과가 예측 불가능해지는 경쟁 상태가 발생한다.

### 잠금(Lock)으로 공유 자원 보호

```java
- 한 번에 하나의 스레드만 접근하도록 제어
- try-finally 블록을 통해 반드시 unlock 보장
- synchronized보다 유연한 제어 가능(대기 시간, 상태 확인 등)

ReentrantLock lock = new ReentrantLock();

try {
    lock.lock();
    // 공유 자원 접근
} finally {
    lock.unlock();
}
```

### 세마포어(Semaphore)

```java
- 동시에 접근 가능한 스레드 수를 제한
- 외부 API 호출, 파일 처리 등 리소스 제한 상황에 유용

Semaphore semaphore = new Semaphore(5);

try {
    semaphore.acquire();
    // 최대 5개 스레드만 동시에 접근 가능
} finally {
    semaphore.release();
}
```

### 읽기 / 쓰기 잠금(Read / Writ Lock)

```java
- 읽기는 여러 쓰레드가 동시에 가능
- 쓰기는 한 번에 하나만 가능
- 일기 많은 시스템의 병목을 완화

ReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.readLock().lock();
// 읽기 처리
rwLock.readLock().unlock();
```

### 원자적 연산으로 락 없이 처리 Atomic 타입 (비잠금 방식)

```java
- 내부적으로 CAS(Compare And Swap)사용
- 별도 락 없이도 스레드 안전하게 값 변경
- AtomicInteger, AtomicLong, AtomicBooleanm 등

AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // 안전한 증가

장점: 락보다 가볍고 빠름
단점: 복잡한 연산(여러 필드 수정 등)은 불가능
```

### 스레드 안전한 컬렉션 사용

```java
Synchronized Collections
- Collections.synchronizedMap(), synchronizedList() 등
- 모든 연산에 락 적용 -> 안전하지만 느림

Map<String, Integer> map = Collections.synchronizedMap(new HashMap<>());

Concurrent Collections
- 락을 필요한 부분에만 최소화하여 성능 개선
- ConcurrentHashMap, ConcurrentLinkedQueue

ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.put("key", 1);
```

#### 결론

동시성 문제는 발생 후 해결보다 사전 대비가 훨씬 중요하다.
단순한 공유 변수부터 컬렉션, DB 접근까지 한 번에 하나의 주체만 수정하도록 제어하는 전략을 세워야 한다.
