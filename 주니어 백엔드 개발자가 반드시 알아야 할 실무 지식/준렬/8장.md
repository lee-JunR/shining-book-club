## 인증과 인과

- 인증: 해당 사용자가 누구인지 식별하는 과정
- 인가: 사용자에게 자원에 접근할 수 있는 권한을 부여

## 인증과 토큰

사용자가 누구인지 확인하는데 성공하면 서버는 클라이언트에 문자열로 된 토큰을 제공한다.

클라이언트는 이후 각 요청마다 해당 토큰을 함께 보내 자신이 누구인지 증명한다.

해당 토큰을 사용해서 사용자가 누구인지 식별하려면 토큰 정보를 어딘가에 저장해야한다.

이 매핑 정보를 저장할 위치로 크게 다음 2가지를 사용한다.

- 서버의 별도 저장소 : 별도 저장소에 토큰과 사용자 식별 정보를 저장한다.
- 토큰 : 토큰 자체에 사용자 식별자 정보를 저장한다.

### 서버의 별도 저장소에 저장.

서버는 토큰과 사용자 식별 정보를 DB 나 별도 저장소에 저장할 수 있다.

외부 저장소의 토큰에 저장되는 정보는 다음과 같다.

- 토큰
- 사용자 식별자
- 생성 시간
- 최근 사용 시간
- 그 외 유효 시간, 클라이어늩 버전 등 추가 데이터

토큰을 외부 저장소에 저장할 경우 별도의 저장 공간이 필요하다. 반면 내부 서버 메모리에 저장할 경우, 여러 서버를 운영할 때 각 서버마다 저장된 토큰 데이터가 달라 문제가 발생할 수 있다.

또한 서버를 재시작하면 모든 토큰 데이터가 사라지며 생성할 수 있는 세션 개수가 메모리 크기에 제한을 받는다.

### 토큰 자체에 사용자 식별자 정보 저장하기

JWT를 사용해서 토큰 자체에 사용자 식별 정보를 저장할 수도 있다.

장점으로는 별도의 외부 저장소가 필요 없다. 그러므로 서버를 수평 확장하기도 쉽다.

하지만 토큰 안에 데이터가 추가되므로 서버와 클라이언트가 주고받는 데이터량 즉 네트워크 트래픽이 증가한다.

그리고 토큰데이터를 서버에서 제어할 수 없다.

## 토큰 송수신

클라이언트가 서버에 토큰을 전송할 때에 다음 2가지 방식 중 하나를 사용한다.

1. 쿠키 : 쿠키를 사용해서 토큰 전송
2. 헤더 : 특정 이름의 헤더에 토큰 전송

웹사이트는 주로 쿠키 방식을 사용한다. 서버 세션도 쿠키를 사용해서 세션 ID를 주고받는다.

헤더를 사용할 수 도 있다. 쿠키도 헤더를 통해 전송되지만 여기서말하는 헤더는 이를 제외한 다른 헤더를 의미한다.

## 토큰 보안

토큰을 탈취한 클라이어느는 원래 토큰 소유자처럼 행세할 수 있으므로 토큰 유효시간에 제한을 두는 것이 좋다.

유효 시간 방식에는 2가지가 있다.

1. 토큰 생성 시점을 기준으로 제한 시간을 두는 방식
2. 마지막 접근 시간을 기준으로 토큰 유효시간을 정하는 방식
   - 서블릿 세션이 이 방식을 사요한다.

일반적인 서비스는 토큰 유효 시간이 짧으면 불편하므로 길게 두고 관리자 사이트처럼 민감 정보를 조회하는 서비스는 반대로 짧게 잡아야한다.

또한 유효시간과 함께 클라이언트 IP를 비교하면 보안에 도움이 된다.

또한 토큰을 무효화해서 강제로 로그아웃 시키는 기능을 구현할 경우 외부 저장소에 토큰 데이터가 있을 경우 해당 저장소에 토큰 데이터를 삭제시키면 된다. 하지만 토큰 자체에 사용자 식별자가 있을 경우 토큰 생성 시간 제한을 두고 이 시간 이전에 생성된 토큰을 유효하지 않은 것으로 보는 방식으로 토큰을 무효화시킬 수 있다.

## 인가와 접근 제어 모델

1. 인증과 토큰은 사용자가 누구인지, 정상적으로 접근했는지 확인하는 역할을 했다면 인가는 사용자가 요청하는 기능을 실행할 권한이 있는지 판단하는 역할을 한다.
2. 접근 제어의 기본은 접근한 사용자를 토큰이나 세션으로 식별하는 것이다.
3. 그러므로 API 요청 파라미터로 사용자의 식별자를 받으면 안된다.
4. 사용자가 접근할 수 있는 기능을 관리하기 위한 모델을 Access-Control 모델이라고 한다.
5. 대표적인 접근 제어 모델로는 역할을 기반으로 접근을 제어하는 RBAC 모델이 있다.
6. 역할을 기반으로 하지 않고 사용자별 권한을 부여할 수 도 있다.
7. 또한 사용자의 속성을 이용해서 접근을 제어하는 ABAC 모델도 있다.

## 데이터 암호화

- 단방향 암호화
  - 해시 함수를 사용해서 데이터를 해시 값으로 변환한다. SHA 256, MD5, Bcrypt 등이 있다.
  - 단방향 암호화는 사용자의 암호를 해시함수로 생성한 해시값을 서버에 저장해두고 해당 해시한 값이 같다면 두 데이터가 같다고 간주한다.
  - 단방향 암호화는 원본 데이터로 복호화가 불가능하기 때문에 사용자가 비밀번호를 잊었을 때 기존 비밀번호를 알려주는 기능은 구현할 수 없다.
  salt 사용하기
  - 원본 데이터를 항상 같은 해시값으로 변환시키면 나중에 보안에 문제가 될 수 있으므로 salt 값과 함께 암호화시켜야한다.
- 양방향 암호화
  - 대칭 키 암호화 (ex. AES)
  - 비대칭 키 암호화 (ex. RSA)
