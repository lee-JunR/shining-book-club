## 인증과 인과

- 인증: 해당 사용자가 누구인지 식별하는 과정
- 인가: 사용자에게 자원에 접근할 수 있는 권한을 부여

## 인증과 토큰

사용자가 누구인지 확인하는데 성공하면 서버는 클라이언트에 문자열로 된 토큰을 제공한다.

클라이언트는 이후 각 요청마다 해당 토큰을 함께 보내 자신이 누구인지 증명한다.

해당 토큰을 사용해서 사용자가 누구인지 식별하려면 토큰 정보를 어딘가에 저장해야한다.

이 매핑 정보를 저장할 위치로 크게 다음 2가지를 사용한다.

- 서버의 별도 저장소 : 별도 저장소에 토큰과 사용자 식별 정보를 저장한다.
- 토큰 : 토큰 자체에 사용자 식별자 정보를 저장한다.

### 서버의 별도 저장소에 저장.

서버는 토큰과 사용자 식별 정보를 DB 나 별도 저장소에 저장할 수 있다.

외부 저장소의 토큰에 저장되는 정보는 다음과 같다.

- 토큰
- 사용자 식별자
- 생성 시간
- 최근 사용 시간
- 그 외 유효 시간, 클라이어늩 버전 등 추가 데이터

토큰을 외부 저장소에 저장할 경우 별도의 저장 공간이 필요하다. 반면 내부 서버 메모리에 저장할 경우, 여러 서버를 운영할 때 각 서버마다 저장된 토큰 데이터가 달라 문제가 발생할 수 있다.

또한 서버를 재시작하면 모든 토큰 데이터가 사라지며 생성할 수 있는 세션 개수가 메모리 크기에 제한을 받는다.

### 토큰 자체에 사용자 식별자 정보 저장하기

JWT를 사용해서 토큰 자체에 사용자 식별 정보를 저장할 수도 있다.

장점으로는 별도의 외부 저장소가 필요 없다. 그러므로 서버를 수평 확장하기도 쉽다.

하지만 토큰 안에 데이터가 추가되므로 서버와 클라이언트가 주고받는 데이터량 즉 네트워크 트래픽이 증가한다.

그리고 토큰데이터를 서버에서 제어할 수 없다.

## 토큰 송수신

클라이언트가 서버에 토큰을 전송할 때에 다음 2가지 방식 중 하나를 사용한다.

1. 쿠키 : 쿠키를 사용해서 토큰 전송
2. 헤더 : 특정 이름의 헤더에 토큰 전송

웹사이트는 주로 쿠키 방식을 사용한다. 서버 세션도 쿠키를 사용해서 세션 ID를 주고받는다.

헤더를 사용할 수 도 있다. 쿠키도 헤더를 통해 전송되지만 여기서말하는 헤더는 이를 제외한 다른 헤더를 의미한다.

## 토큰 보안

토큰을 탈취한 클라이어느는 원래 토큰 소유자처럼 행세할 수 있으므로 토큰 유효시간에 제한을 두는 것이 좋다.

유효 시간 방식에는 2가지가 있다.

1. 토큰 생성 시점을 기준으로 제한 시간을 두는 방식
2. 마지막 접근 시간을 기준으로 토큰 유효시간을 정하는 방식
   - 서블릿 세션이 이 방식을 사요한다.

일반적인 서비스는 토큰 유효 시간이 짧으면 불편하므로 길게 두고 관리자 사이트처럼 민감 정보를 조회하는 서비스는 반대로 짧게 잡아야한다.

또한 유효시간과 함께 클라이언트 IP를 비교하면 보안에 도움이 된다.

또한 토큰을 무효화해서 강제로 로그아웃 시키는 기능을 구현할 경우 외부 저장소에 토큰 데이터가 있을 경우 해당 저장소에 토큰 데이터를 삭제시키면 된다. 하지만 토큰 자체에 사용자 식별자가 있을 경우 토큰 생성 시간 제한을 두고 이 시간 이전에 생성된 토큰을 유효하지 않은 것으로 보는 방식으로 토큰을 무효화시킬 수 있다.

## 인가와 접근 제어 모델

1. 인증과 토큰은 사용자가 누구인지, 정상적으로 접근했는지 확인하는 역할을 했다면 인가는 사용자가 요청하는 기능을 실행할 권한이 있는지 판단하는 역할을 한다.
2. 접근 제어의 기본은 접근한 사용자를 토큰이나 세션으로 식별하는 것이다.
3. 그러므로 API 요청 파라미터로 사용자의 식별자를 받으면 안된다.
4. 사용자가 접근할 수 있는 기능을 관리하기 위한 모델을 Access-Control 모델이라고 한다.
5. 대표적인 접근 제어 모델로는 역할을 기반으로 접근을 제어하는 RBAC 모델이 있다.
6. 역할을 기반으로 하지 않고 사용자별 권한을 부여할 수 도 있다.
7. 또한 사용자의 속성을 이용해서 접근을 제어하는 ABAC 모델도 있다.

## 데이터 암호화

- 단방향 암호화
  - 해시 함수를 사용해서 데이터를 해시 값으로 변환한다. SHA 256, MD5, Bcrypt 등이 있다.
  - 단방향 암호화는 사용자의 암호를 해시함수로 생성한 해시값을 서버에 저장해두고 해당 해시한 값이 같다면 두 데이터가 같다고 간주한다.
  - 단방향 암호화는 원본 데이터로 복호화가 불가능하기 때문에 사용자가 비밀번호를 잊었을 때 기존 비밀번호를 알려주는 기능은 구현할 수 없다.
  salt 사용하기
  - 원본 데이터를 항상 같은 해시값으로 변환시키면 나중에 보안에 문제가 될 수 있으므로 salt 값과 함께 암호화시켜야한다.
- 양방향 암호화
  - 대칭 키 암호화 (ex. AES)
  - 비대칭 키 암호화 (ex. RSA)

## HMAC을 이용한 데이터 검증

1. HMAC은 메시지 무결성과 인증을 보장하기 위한 암호화 기술이다.
2. HMAC은 해시와 비밀키를 이용해서 무결성과 인증을 보장한다.
3. 발신자와 수신자가 비밀키를 공유하고 해당 비밀키로 메시지를 해싱한 MAC 을 보낸다.
4. 수신자는 메시지와 키를 이용해서 생성한 MAC 과 발신자가 보낸 MAC이 같은지 비교한다.

## 방화벽으로 필요한 트래픽만 허용하기

1. 방화벽은 네트워크가 들어오는 가장 첫번째 관문이다.
2. 방화벽은 네트워크 통신을 두 방향으로 제어한다.
   1. 인바운드 트래픽
      - 외부에서 내부로 유입되는 것
   2. 아웃바운드 트래픽
      - 내부에서 외부로 유출되는것
3. 기본적으로 인바운드 트래픽은 필수 트래픽만 허요하고 나머지는 차단할 것을 권한다.
4. 특정 서버 IP 의 443만 허용하고 나머지를 차단하는 식으로 외부 노출을 최소화해야한다.
   - 서비스 API : 외부의 모든 IP에서 서버 A IP의 443 포트로 접근 가능
   - 관리자 API : 사내 IP 만 서버 B IP의 433 포트로 접근 가능
5. DDoS 나 포트 스캔 같은 네트워크 공격을 차단하는 기능도 제공한다.
6. 웹 방화벽을 사용하면 HTTP/HTTPS 수준에서 발생하는 공격도 방어할 수 있다.

## 감사 로그 (audit log) 남기기

1. 감사 로그는 특정 작업, 절차 ,사건 또는 장치에 영향을 주는 활동의 순서를 입증하는 기록이다.
2. 감사 로그로 넣을만한 대상은 사용자의 로그인/아웃 내역, 암호 초기화 등 설정 변경 내역, 환자 기록을 조회한 의료진 정보, 계약서의 수정 이력 등이 있을 수 있다.

## 데이터 노출 줄이기

1. 다수의 고객 정보를 쉽게 획득하지 못하는 방법으로 마스킹이 있다.
2. 소수 인원에게만 고객 목록 조회 권한을 부여하는 방법도 있다.
3. 로그 메시지도 평문을 사용하지 않도록 신경써야한다.

## 비정상 접근 처리

1. 사용자가 평소와 다른 행동 패턴을 보이면 비정상 접근으로 판단하고 사용자에게 해당 내용을 알려줄 수 있어야한다.
2. 비정상 접근으로 판단하는 예로는
   - 평소와 다른 장소에서 로그인 함
   - 평소와 다른 기기에서 로그인함
   - 로그인에 여러 차례 실패함
3. 이 3가지는 시스템적으로 보안을 강화하면 좋다.

## 시큐어 코딩

1. SQL 인젝션 공격에 대응할 수 있도록 Prepared Statement 를 사용하자.
2. 또한 아래 항목에 신경쓰자
   - 입력 값 검증 : 클라이언트가 전송한 값이 올바르다고 가정하지 말고 모든 값을 검증하자. 필수여부, 길이 제한 미허용 값
   - 개인정보/민감정보 암호화 : 로그인 암호와 바이오 정보처럼 인증에 사용되는 정보 뿐 아니라 주민번호, 운전 면허 번호 같은 고유 식별 정보도 암호화해야한다.
   - 에러 메시지에 시스템 정보 미노출 : 에러 메시지에 IP 와 같은 정보가 노출되지 않도록 신경쓰자
   - 보안 통신 HTTPS ㅅ처럼 데이터를 암호화해서 송수신하자
   - CORS 설정: 허용된 도메인만 서버 자원에 접근할 수 있도록 제한한다.
   - CSRF 대응 : 주요 기능은 타 사이트에서 위조 공격이 들어오는 것을 방지하기 위해 CSRF 토큰, SmaeSite 쿠키, 캡챠 등을 활용하자
