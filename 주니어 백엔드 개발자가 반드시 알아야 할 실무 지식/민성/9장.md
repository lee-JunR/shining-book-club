9장. 최소한 알고 있어야 할 서버 지식 (핵심 요약)
백엔드 개발자가 서버 OS(Linux)를 알아야 하는 이유는 장애 발생 시 문제의 원인이 애플리케이션인지, OS 설정 문제인지 파악하기 위해서입니다.

1. OS 계정과 권한 (Account & Permission)
   서버에는 모든 권한을 가진 Root 계정과 제한된 권한을 가진 일반 계정이 있습니다.

핵심 개념
권한 문제: Root로 생성한 파일을 일반 계정이 수정하려다 에러가 나는 경우가 많습니다.

chmod (권한 변경): 파일의 읽기(r=4), 쓰기(w=2), 실행(x=1) 권한을 숫자로 설정합니다.

chmod 755 file.sh: 소유자(모두), 그룹(읽기/실행), 타인(읽기/실행)

주의: 777은 보안상 위험하므로 꼭 필요한 만큼만 부여하세요.

sudo: 일반 사용자가 임시로 관리자(root) 권한을 사용할 때 씁니다.

설정 파일: /etc/sudoers (수정 시 visudo 명령어 사용 권장)

2. 프로세스 관리 (Process)
   서버가 제대로 뜨지 않거나 죽지 않을 때 확인해야 합니다.

상태 확인
ps aux 또는 ps -eaf: 현재 실행 중인 프로세스 목록 확인 (PID 확인용).

top 또는 htop: CPU, 메모리 점유율을 실시간으로 확인.

프로세스 종료 (kill)
kill -15 [PID]: (권장) 프로세스에게 종료 신호(TERM)를 보냅니다. 자원을 정리하고 안전하게 종료됩니다.

kill -9 [PID]: (최후의 수단) 프로세스를 강제 종료합니다. 데이터 유실 위험이 있습니다.

백그라운드 실행
터미널을 꺼도 서버가 계속 돌아가게 하려면:

&: 명령어 뒤에 붙이면 백그라운드에서 실행됩니다.

nohup: 로그아웃해도 프로세스가 죽지 않게 합니다.

실무 패턴: nohup java -jar server.jar & (로그는 nohup.out에 남음)

3. 디스크 용량 관리 (Disk Usage)
   디스크가 100%가 되면 서버가 멈추거나 재부팅됩니다. 주원인은 로그 파일입니다.

용량 확인
df -h: 전체 디스크 파티션 별 사용량 확인 (Human-readable 단위).

du -sh [경로]: 특정 디렉토리나 파일의 용량 확인.

긴급 조치 (꿀팁)
로그 때문에 디스크가 꽉 찼는데 서버를 재시작할 수 없다면?

cp /dev/null access.log: 로그 파일 내용을 비워서(0바이트) 용량을 확보합니다. (파일 삭제보다 안전)

4. 파일 디스크립터 (File Descriptor)
   리눅스는 파일이나 소켓을 열 때 '파일 디스크립터'를 할당합니다. 이 개수에 제한이 있습니다.

증상: 트래픽이 몰릴 때 Too Many Open Files 에러 발생.

확인: ulimit -n (현재 제한 확인), lsof -p [PID] (특정 프로세스가 연 파일 확인).

해결: /etc/security/limits.conf 등에서 제한 값을 늘려줘야 합니다.

5. 시간 동기화 & 스케줄링
   시간 동기화
   서버 시간이 틀어지면 로그 분석이 어렵고, 시간 제한이 있는 API 호출 시 에러가 발생합니다.

chrony, ntp 등을 이용해 주기적으로 시간을 맞춰야 합니다.

크론 (Cron) - 스케줄러
주기적인 작업(로그 삭제, DB 백업 등)을 자동화합니다.

명령어: crontab -e (수정), crontab -l (목록 확인)

문법: 분 시 일 월 요일 명령어 순서입니다.

6. 네트워크 확인
   연결이 안 될 때, 내 문제인지 네트워크 문제인지 파악해야 합니다.

ifconfig: 내 서버의 IP 주소 확인.

netstat -lputn: 현재 내 서버에서 어떤 포트가 열려있는지(Listen) 확인. 포트 충돌 확인 시 유용.

nc -z -v [IP] [PORT]: (중요) 상대방 서버의 포트가 열려있는지 확인할 때 가장 확실한 방법입니다. (예: nc -z -v google.com 443)

7. 생산성 팁 (Alias)
   자주 가는 긴 경로나 긴 명령어를 단축키처럼 등록하세요.

등록: .bashrc 파일에 alias 별칭='긴 명령어' 추가.

예: alias log='cd /var/www/logs && tail -f access.log'