1. 🤔 동시성이란 무엇이며 왜 중요한가?
   서버는 높은 성능(처리량, 응답 시간)을 위해 여러 클라이언트의 요청을 동시에 처리해야 합니다. 만약 요청을 하나씩 순서대로 처리한다면, 1개 요청에 0.1초가 걸릴 때 100개 요청을 처리하는 데 총 10초가 걸립니다. 하지만 10개씩 동시에 처리하면 1초면 충분합니다.

서버는 '요청마다 스레드 할당' 또는 '비동기 IO' 방식을 사용해 동시 실행을 구현하며, 이 과정에서 여러 스레드가 동시에 같은 데이터(공유 자원)에 접근할 수 있습니다.

2. 💣 동시성 문제 (경쟁 상태)
   동시 실행을 고려하지 않고 코드를 작성하면, 여러 스레드가 공유 자원에 접근하는 순서에 따라 결과가 달라지는 **'경쟁 상태(Race Condition)'**가 발생합니다. 이는 데이터를 손상시키고 심각한 버그를 유발합니다.

주요 문제 사례:

간단한 증감 연산 (count++): count = count + 1은 실제로는 '1. count 값 읽기', '2. 1 더하기', '3. count에 저장'의 3단계로 동작합니다. 두 스레드가 동시에 '1. count 값 읽기'를 실행하면(예: 둘 다 5를 읽음), 두 스레드가 각각 1을 더해 6을 저장하여 최종 결과가 7이 아닌 6이 되는 문제가 발생합니다. (10000번을 실행해도 9982처럼 누락 발생)

잘못된 필드 공유 (PayService 예시): PayService 객체가 싱글톤일 때, 여러 스레드가 payId라는 클래스 필드를 공유하는 것이 문제입니다.

스레드 1이 payId를 1로 설정합니다.

스레드 1이 다음 단계로 넘어가기 직전, 스레드 2가 끼어들어 payId를 2로 덮어씁니다.

스레드 1이 나중에 이 payId를 참조하면, 자신이 설정한 1이 아닌 2를 사용하게 되어 엉뚱한 결제 데이터를 수정하는 심각한 오류가 발생합니다.

DB 데이터 동시 수정: 고객이 '주문 취소'를 하는 동시에 관리자가 '배송 처리'를 할 수 있습니다. 두 요청이 거의 동시에 DB에 접근하면, '주문 정보 조회'는 둘 다 성공하지만, '취소 상태 변경' 직후에 '배송 상태 변경'이 덮어쓰여, 고객은 취소했음에도 배송이 시작되는 문제가 생길 수 있습니다.

3. 🔒 해결 방법: 동시 접근 제어
   잠금 (Lock / Mutex)
   가장 일반적인 해결책은 **'잠금(Lock)'**을 사용하는 것입니다. 잠금은 동시에 여러 스레드가 접근하면 안 되는 코드 영역(이를 **'임계 영역, Critical Section'**이라 함)에 한 번에 하나의 스레드만 접근하도록 제한합니다.

동작 방식:

스레드 1이 잠금을 획득합니다.

스레드 1이 임계 영역(공유 자원 접근 코드)을 실행합니다.

스레드 1이 잠금을 해제합니다.

스레드 1이 잠금을 가진 동안, 스레드 2는 잠금을 획득하기 위해 대기해야 합니다.

Java 예시: HashMap처럼 스레드에 안전하지 않은 자원을 보호하기 위해 ReentrantLock (또는 synchronized 키워드)을 사용합니다. lock.lock()으로 잠금을 획득하고, finally 절에서 반드시 lock.unlock()을 호출해 잠금을 해제해야 합니다.

기타 동시성 제어 도구
세마포어 (Semaphore): 잠금이 '오직 1개'의 스레드만 허용하는 것과 달리, 세마포어는 **'지정된 개수(N개)'**만큼의 스레드가 동시에 접근하는 것을 허용합니다. (예: 외부 API 호출을 동시에 최대 5개로 제한할 때 사용)