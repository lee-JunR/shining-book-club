# 백엔드 개발 가이드 - 5장 정리

## 5장: 비동기 연동, 언제 어떻게 써야 할까

### 📍 핵심 아이디어
> **동기 방식이 외부 연동을 만나면 전체 기능의 실패 위험과 성능 저하가 발생한다. 비동기 연동을 통해 시스템 간 영향을 최소화하고 성능을 개선하자.**

---

## 1. 동기 vs 비동기 연동

### 동기 연동의 특징
- **순차적 실행**: 한 작업이 끝날 때까지 다음 작업이 진행되지 않음
- **직관적 이해**: 프로그램 흐름을 쉽게 파악 가능
- **디버깅 용이**: 코드를 그대로 따라가며 분석 가능

### 동기 연동의 문제점
- **전체 기능 실패 위험**: 외부 서비스 장애 시 전체 기능 사용 불가
- **응답 시간 지연**: 외부 서비스 응답 시간만큼 전체 응답 시간 증가
- **연쇄 장애 가능성**: 외부 서비스 성능 저하가 전체 시스템에 영향

### 비동기 연동이 적합한 상황

1. **시차 허용**: 연동에 약간의 시차가 생겨도 문제되지 않는 기능
2. **재시도 가능**: 실패 시 재시도로 해결 가능한 기능
3. **수동 처리 가능**: 연동 실패 시 나중에 수동으로 처리 가능한 기능
4. **무시 가능**: 연동 실패해도 무시할 수 있는 기능

**비동기 연동 적용 사례:**
- 포인트 지급
- 주문 정보 동기화
- 택배사 집하 요청
- 푸시 알림 발송
- 검색 엔진 연동

---

## 2. 비동기 연동 구현 방법

### 방법 1: 별도 스레드로 실행하기

**장점:**
- 구현이 간단함
- 기존 코드 수정 최소화

**단점:**
- 트랜잭션 연동 문제
- 오류 처리의 복잡성
- 메모리 사용량 증가

**구현 예시:**
```java
@Async
public void sendPushAsync(PushData pushData) {
    try {
        pushClient.sendPush(pushData);
    } catch(Exception e) {
        // 재시도 또는 실패 로그 처리
        recordFailure(pushData, e);
    }
}
```

**주의사항:**
- 메서드 이름에 비동기 관련 단어 추가 (`sendPushAsync`)
- 트랜잭션 범위 내에서 비동기 실행 시 롤백 불가
- 스레드 풀 사용으로 메모리 사용량 제한
- 가상 스레드나 고루틴 고려

---

### 방법 2: 메시징 시스템 이용하기

**구조:**
```
시스템 A → 메시징 시스템 → 시스템 B
```

**주요 장점:**
1. **시스템 간 독립성**: 서로 영향을 주지 않음
2. **버퍼 역할**: 트래픽 급증 시에도 안정적 처리
3. **확장 용이성**: 새로운 소비자 시스템 추가 간편

**메시징 시스템 선택 기준:**

| 기술 | 특징 | 사용 상황 |
|------|------|-----------|
| **카프카** | • 높은 처리량 (초당 백만+ 메시지)<br>• 수평 확장 용이<br>• 메시지 영구 보관<br>• 파티션별 순서 보장 | 대량 트래픽<br>(초당 수십만~백만 메시지) |
| **래빗MQ** | • 다양한 프로토콜 지원<br>• 순서 보장<br>• 전달 확인 기능<br>• 다재다능함 | 메시지 순서 중요<br>AMQP/STOMP 연동 필요 |
| **레디스 pub/sub** | • 짧은 지연시간<br>• 높은 처리량<br>• 간단한 모델 | 메시지 유실 허용<br>간단한 구조 선호 |

**메시지 생성 측 고려사항:**

1. **메시지 유실 대응:**
    - 무시: 단순 로그성 메시지
    - 재시도: 일시적 네트워크 오류
    - 실패 로그: 후처리용 데이터 보관

2. **DB 트랜잭션 연동:**
   ```java
   // ❌ 잘못된 순서 - 롤백 시 잘못된 메시지 전송
   db.update();
   messaging.send(message);
   db.commit(); // 실패 시 롤백되지만 메시지는 이미 전송됨
   
   // ✅ 올바른 순서 - 트랜잭션 완료 후 메시지 전송
   db.update();
   db.commit();
   messaging.send(message);
   ```

**메시지 소비 측 고려사항:**

1. **중복 메시지 처리:**
   ```java
   while(true) {
       Message m = consumer.poll();
       if (checkAlreadyHandled(m.getId())) {
           continue; // 이미 처리된 메시지는 무시
       }
       handle(m);
       recordHandledLog(m.getId());
   }
   ```

2. **멱등성 보장:** API가 여러 번 호출되어도 결과가 동일하도록 구현
3. **모니터링:** 메시지 처리 속도와 큐 상태 지속적 확인

**메시지 유형:**

| 유형 | 특징 | 예시 |
|------|------|------|
| **이벤트** | • 발생한 사실 전달<br>• 정해진 수신자 없음<br>• 관심있는 소비자가 수신 | • 주문함<br>• 배송 완료함<br>• 로그인 실패함 |
| **커맨드** | • 특정 작업 요청<br>• 정해진 수신자 있음<br>• 기능 실행 초점 | • 포인트 지급하기<br>• 문자 발송하기<br>• 로그인 차단하기 |

---

### 방법 3: 트랜잭션 아웃박스 패턴

**목적:** DB 트랜잭션과 메시지 발송을 안전하게 연동

**동작 과정:**
1. **DB 트랜잭션 내에서 처리:**
    - 업무 로직 데이터 변경
    - 아웃박스 테이블에 메시지 데이터 추가
2. **별도 프로세스에서 메시지 중계:**
    - 아웃박스 테이블에서 대기 메시지 조회
    - 메시징 시스템에 전송
    - 전송 완료 표시

**아웃박스 테이블 구조:**
```sql
CREATE TABLE outbox (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    message_id VARCHAR(255) UNIQUE,
    message_type VARCHAR(100),
    payload CLOB,
    status VARCHAR(20), -- WAITING, DONE, FAILED
    fail_count INT DEFAULT 0,
    occurred_at TIMESTAMP,
    processed_at TIMESTAMP,
    failed_at TIMESTAMP
);
```

**메시지 중계 코드:**
```java
public void processMessages() {
    List<MessageData> waitingMessages = selectWaitingMessages();
    for (MessageData m : waitingMessages) {
        try {
            sendMessage(m);
            markDone(m.getId());
        } catch (Exception ex) {
            handleError(ex);
            break; // 순서 보장을 위해 실패 시 중단
        }
    }
}
```

**장점:**
- 메시지 데이터 유실 방지
- 잘못된 메시지 전송 방지
- 순서 보장 가능

**고려사항:**
- 발송 완료 표시 방법 (상태 칼럼 vs 마지막 ID 기록)
- 실패 메시지 후처리 정책
- 메시지 중계 서비스 이중화

---

### 방법 4: 배치 전송

**특징:**
- 가장 전통적인 비동기 연동 방법
- 일정 간격으로 데이터를 일괄 전송
- 파일 또는 API를 통한 데이터 전송

**배치 전송 과정:**
1. 전송할 데이터를 수집/집계
2. 정해진 형식으로 파일 생성 (CSV, JSON, XML 등)
3. 지정된 시간에 파일 전송/업로드
4. 수신 측에서 파일 처리
5. 처리 완료된 파일을 백업 폴더로 이동

**파일 전송 시 결정사항:**

| 항목 | 고려사항 |
|------|----------|
| **송수신 주체** | 생산자가 업로드 vs 소비자가 다운로드 |
| **시간** | 처리 시간대, 시간대 차이 고려 |
| **경로** | 파일 저장 위치, 명명 규칙 |
| **형식** | CSV, JSON, XML 등 데이터 형식 |

**구현 고려사항:**
- **재처리 기능**: 실패 시 자동/수동 재실행
- **빈 파일 정책**: 데이터 없을 때도 빈 파일 전송으로 혼란 방지
- **모니터링**: 파일 생성/전송 상태 확인
- **백업**: 처리 완료 파일 보관

---

### 방법 5: CDC (Change Data Capture)

**정의:** 데이터 변경을 추적하여 변경된 데이터로 작업을 수행하는 패턴

**동작 과정:**
```
DB 데이터 변경 → DB가 CDC 처리기에 변경 통지 → 대상 시스템에 변경분 전파
```

**특징:**
- 커밋된 데이터만 순서대로 전달
- 롤백된 데이터는 전달되지 않음
- 레코드 단위로 변경분 전달 (INSERT/UPDATE/DELETE 구분)
- 수정 시 이전 값과 이후 값 포함

**장점:**
- 실시간에 가까운 데이터 동기화
- 애플리케이션 코드 수정 최소화
- 데이터 일관성 보장

**단점:**
- DBMS별 구현 방식 상이
- 초기 설정 복잡성
- 스키마 변경 시 영향도 고려 필요

---

## 3. 비동기 연동 방식 선택 가이드

### 상황별 권장 방식

| 상황 | 권장 방식 | 이유 |
|------|-----------|------|
| **간단한 알림/로그** | 별도 스레드 | 구현 간단, 유실 허용 |
| **시스템 간 연동** | 메시징 시스템 | 독립성, 확장성 |
| **데이터 정합성 중요** | 트랜잭션 아웃박스 | 메시지 유실 방지 |
| **대용량 데이터** | 배치 전송 | 안정적 대용량 처리 |
| **실시간 동기화** | CDC | 지연 시간 최소화 |

### 성능 고려사항

| 방식 | 처리량 | 지연시간 | 복잡도 | 안정성 |
|------|--------|----------|--------|--------|
| **별도 스레드** | 중간 | 낮음 | 낮음 | 중간 |
| **메시징** | 높음 | 낮음 | 중간 | 높음 |
| **아웃박스** | 중간 | 중간 | 높음 | 높음 |
| **배치** | 매우 높음 | 높음 | 중간 | 높음 |
| **CDC** | 높음 | 매우 낮음 | 높음 | 높음 |

