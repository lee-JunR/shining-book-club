## 2장: 느려진 서비스, 어디부터 봐야 할까?

서버 성능이 저하되면 응답이 느려지거나 타임아웃 오류가 발생합니다. 사용자는 이 시간을 기준으로 성능을 판단하지만, 실제 서버 성능은 **응답 시간(Response Time)**과 **처리량(Throughput)**이라는 두 가지 핵심 지표로 평가할 수 있습니다.

---

### 1. 성능의 핵심 지표: 응답 시간과 처리량

### **응답 시간 (Response Time)**

사용자가 요청을 보낸 후 전체 응답을 받을 때까지 걸리는 시간입니다.

- **구성 요소**:
    1. **요청 전송 시간**: 클라이언트가 서버에 연결하고 데이터를 보내는 시간
    2. **서버 처리 시간**: 로직 수행, DB 연동, 외부 API 호출 등 실제 작업을 처리하는 시간
    3. **응답 전송 시간**: 처리 결과를 클라이언트에 보내는 시간
- **핵심**: 서버 처리 시간 중에서도 **DB 연동**과 **외부 API 연동**이 응답 시간의 대부분(70~80% 이상)을 차지하므로, 성능 개선 시 이 부분을 집중적으로 분석해야 합니다.
- **측정 단위**: 주로 밀리초(ms, 1/1000초)를 사용합니다.
- **사업적 영향**: 응답 시간이 100ms만 늘어도 매출이 1% 감소할 수 있다는 통계가 있을 만큼, 응답 시간은 사용자 이탈 및 매출과 직결됩니다.

### **처리량 (Throughput)**

단위 시간당 시스템이 처리할 수 있는 작업량으로, 보통 **TPS(Transaction Per Second)** 또는 **RPS(Request Per Second)**로 표현합니다.

- **최대 TPS 초과**: 시스템이 처리할 수 있는 최대 요청 수를 초과하면, 나머지 요청들은 대기 상태가 되어 응답 시간이 급격히 늘어납니다.
- **TPS를 높이는 방법**:
    1. 동시에 처리할 수 있는 요청 수를 늘립니다. (서버 확장 등)
    2. 개별 요청의 처리 시간(응답 시간)을 줄입니다.
- **확인 방법**: 스카우터(Scouter), 핀포인트(Pinpoint) 같은 모니터링 툴이나 웹 서버 접근 로그를 통해 확인할 수 있습니다.

---

### 2. 서버 성능 개선 기초

성능을 개선하려면 먼저 **병목 지점(bottleneck)**을 정확히 찾아야 합니다. 대부분의 병목은 **DB** 또는 **외부 API 연동** 과정에서 발생합니다.

### **1. 확장 (Scaling)**

- **수직 확장 (Scale-up)**: 기존 서버의 자원(CPU, 메모리, 디스크 등)을 증설하는 방법입니다. 긴급한 상황에서 빠르게 성능을 개선할 수 있지만, 비용이 많이 들고 한계가 명확합니다.
- **수평 확장 (Scale-out)**: 서버 대수를 늘려 처리량을 높이는 방법입니다. **로드 밸런서**가 필수이며, 실제 병목이 발생하는 지점(예: DB)의 상태를 고려하지 않고 웹 서버만 늘리면 오히려 성능이 악화될 수 있습니다.

### **2. DB 커넥션 풀 (DB Connection Pool)**

DB 연결 생성 및 종료는 매우 비용이 큰 작업입니다. 이 문제를 해결하기 위해 커넥션을 미리 만들어두고 재사용하는 **커넥션 풀**은 필수입니다.

- **주요 설정**:
    - **커넥션 풀 크기**: 동시에 처리할 수 있는 DB 작업 수를 결정하는 가장 중요한 설정입니다. 너무 작으면 요청이 대기하고, 너무 크면 DB에 과부하를 줄 수 있습니다.
    - **커넥션 대기 시간**: 풀에 남는 커넥션이 없을 때 대기할 최대 시간입니다. 이 시간을 짧게 설정하면, 무한정 대기하는 대신 사용자에게 빠르게 오류를 반환하여 서버 부하를 줄일 수 있습니다.
    - **최대 유휴/유지 시간**: 사용되지 않는 커넥션을 자동으로 정리하여 DB와의 연결 끊김 문제를 방지합니다.

### **3. 서버 캐시 (Cache)**

자주 조회하지만 잘 변하지 않는 데이터를 DB 대신 메모리(캐시)에 저장하여 응답 시간을 단축하고 DB 부하를 줄이는 기술입니다.

- **동작 방식**: 요청 시 캐시를 먼저 조회하고, 데이터가 없으면(Cache Miss) DB에서 조회한 후 캐시에 저장합니다.
- **로컬 캐시 vs. 리모트 캐시**:
    - **로컬 캐시**: 서버 메모리 내에 저장. 속도가 매우 빠르지만, 서버 재시작 시 데이터가 사라지고 다른 서버와 공유되지 않습니다.
    - **리모트 캐시 (Redis 등)**: 별도의 캐시 서버 사용. 네트워크 통신이 필요해 상대적으로 느리지만, 여러 서버가 데이터를 공유할 수 있고 서버 재시작에도 데이터가 유지됩니다.
- **캐시 무효화**: 원본 데이터가 변경될 때 캐시의 데이터도 함께 삭제하거나 갱신해야 데이터 불일치 문제를 막을 수 있습니다.

### **4. 가비지 컬렉터(GC)와 메모리 관리**

GC는 메모리를 자동으로 관리해주지만, 실행되는 동안 애플리케이션이 일시 중단("Stop-The-World")되어 응답 시간에 영향을 줄 수 있습니다.

- **개선 방안**:
    - **불필요한 객체 생성 최소화**: 한 번에 대량의 데이터를 조회해 메모리에 올리는 것을 피하고, 조회 범위를 제한합니다.
    - **스트림(Stream) 활용**: 대용량 파일 다운로드 시, 전체 파일을 메모리에 올리지 않고 작은 단위로 나누어 처리하면 메모리 사용량을 크게 줄일 수 있습니다.

### **5. 정적 자원 관리 및 최적화**

이미지, CSS, JS 파일 같은 **정적 자원**은 전체 트래픽의 상당 부분을 차지하므로 최적화가 중요합니다.

- **응답 데이터 압축**: JSON, HTML 같은 텍스트 데이터를 gzip 등으로 압축하면 전송 크기를 70% 이상 줄여 응답 시간을 단축하고 네트워크 비용을 절감할 수 있습니다.
- **브라우저 캐시**: `Cache-Control` 헤더를 이용해 사용자가 한번 받은 정적 자원을 재사용하도록 하여 불필요한 트래픽을 줄입니다.
- **CDN (Content Delivery Network)**: 콘텐츠를 사용자에게 지리적으로 가까운 서버에 캐싱하여 전송 속도를 높이고, 원본 서버의 부하를 획기적으로 줄여줍니다.

### **6. 대기 처리 시스템**

콘서트 예매처럼 순간적으로 트래픽이 폭증할 때, 시스템이 처리할 수 있는 만큼의 요청만 받고 나머지는 대기열로 보내는 방식입니다. 과도한 서버 증설 없이 안정적으로 서비스를 운영할 수 있는 합리적인 방법입니다.