🎯 핵심 요약: DB와 동시성
1. DB 트랜잭션의 한계

트랜잭션은 데이터 일관성을 보장하지만, 동시에 같은 데이터를 수정하는 문제는 못 막음
예: 배송 시작과 주문 취소가 동시에 실행되면 데이터가 꼬일 수 있음

2. 두 가지 잠금 방식
   선점(비관적) 잠금

개념: 먼저 접근한 사람이 독점 → 다른 사람은 대기
SQL: SELECT ... FOR UPDATE
장점: 확실하게 동시 수정 방지
단점: 대기 시간 발생 (응답 느려짐)
언제: 외부 시스템 연동할 때 (예: PG 결제 취소)

비선점(낙관적) 잠금

개념: 일단 처리 시도 → version 번호로 확인 → 다르면 실패
방법:

sql  UPDATE table SET version = version + 1, ...
WHERE id = ? AND version = [조회한값]

장점: 대기 없어서 응답 빠름
단점: 실패 가능성 있음
언제: 빠른 응답이 중요할 때

3. 증분 쿼리 (꿀팁!)
   sql-- ❌ 나쁜 예: 조회 후 +1
   joinCount = 조회값 + 1

-- ✅ 좋은 예: DB가 알아서 처리
UPDATE SET joinCount = joinCount + 1

잠금 없이도 동시성 문제 해결!

4. 잠금 사용 시 주의사항
   반드시 해제하기
   javalock.lock();
   try {
   // 코드
   } finally {
   lock.unlock(); // 무조건 해제!
   }
   대기 시간 제한
   javaboolean acquired = lock.tryLock(5, TimeUnit.SECONDS);
   if (!acquired) {
   throw new RuntimeException("잠금 실패");
   }
```

**교착상태(Deadlock) 피하기**
- 문제: A가 자원1 잠금 → B가 자원2 잠금 → 서로 대기 → 무한 대기
- 해결: **정해진 순서대로** 잠금 획득 (예: 항상 ID 작은 것부터)

### 5. **단일 스레드 방식** (고급 기법)
```
요청들 → [작업 큐] → [한 스레드만 처리] → 상태 변경

장점: 동시성 문제 원천 차단
단점: 구조 복잡함
언제: 비동기 IO 사용하거나, 동시성 문제가 정말 복잡할 때


💡 실전 선택 가이드
상황추천 방법단순 카운트 증가증분 쿼리외부 API 호출 있음선점 잠금빠른 응답 필요비선점 잠금동시 접근 많고 복잡단일 스레드 방식
가장 중요한 건: 항상 finally에서 잠금 해제! 👈