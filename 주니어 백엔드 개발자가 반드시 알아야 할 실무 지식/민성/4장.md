## 4장 정리

1. 타임아웃 (Timeout): 무한정 기다리지 마라
   외부 API를 호출할 때 응답을 무한정 기다리면 안 됩니다.

문제 상황:

A 서비스(내 서비스, 스레드 200개)가 B 서비스(외부)를 호출합니다.

B 서비스가 느려져서 응답에 60초가 걸립니다.

사용자 요청이 200개만 들어와도, A 서비스의 스레드 200개가 모두 B 서비스의 응답을 기다리며 마비됩니다.

이후 들어오는 모든 요청(B 서비스와 관련 없는 기능 포함)은 처리되지 못하고 쌓이게 되어, 서비스 전체가 장애를 겪습니다.

해결책: 타임아웃 설정

타임아웃을 5초로 설정하면, A 서비스는 B 서비스의 응답을 최대 5초만 기다립니다.

5초가 지나면 B 서비스 응답을 포기하고 사용자에게 "시간 초과 오류"를 보냅니다.

중요한 것은, A 서비스의 스레드가 자원을 반납하고 다른 요청을 처리할 수 있게 된다는 점입니다.

결론: 무한 대기 화면보다 빠른 오류 화면이 낫습니다.

2가지 타임아웃:

Connection Timeout (연결 타임아웃): 외부 서비스와 '연결' 자체를 시도하는 시간. (보통 3~5초)

Read Timeout (읽기 타임아웃): 연결은 되었는데, '데이터 응답'을 기다리는 시간. (보통 5~30초)

주의! 결제 API처럼 민감한 기능은 읽기 타임아웃을 너무 짧게 잡으면 안 됩니다. (예: 5초 타임아웃 났는데, 실제로는 10초 뒤에 결제 성공. → 고객은 돈만 나가고 구매 실패)

2. 재시도 (Retry): 실패했을 때 다시 해볼까?
   네트워크는 일시적으로 불안정할 수 있습니다. 재시도를 통해 간헐적인 오류를 성공으로 바꿀 수 있습니다.

재시도가 가능한 경우 (필수 조건):

단순 조회 (Read): 몇 번을 호출해도 결과가 같습니다. (예: 사용자 정보 조회)

연결 타임아웃 (Connection Timeout): 애초에 요청이 전달되지 않았으므로 다시 시도해도 안전합니다.

멱등성(Idempotent)이 보장될 때: 여러 번 호출해도 결과가 똑같은 변경 요청. (예: '좋아요' API. 10번 눌러도 '좋아요'는 1개)

재시도하면 위험한 경우:

읽기 타임아웃 (Read Timeout): 내 쪽에서는 응답을 못 받았지만, 외부 서비스는 처리를 완료했을 수 있습니다.

(절대 금지!) '포인트 차감' API를 재시도 → 포인트가 이중으로 차감될 수 있습니다.

재시도 방법:

횟수: 1~2번 정도가 적당합니다. (총 2~3회 시도)

간격: 즉시 재시도하지 마세요. 일시적 장애가 회복될 시간을 줘야 합니다. (예: 1초 뒤, 3초 뒤...)

3. 동시 요청 제한 (Bulkhead): 과부하 전파 막기
   외부 서비스가 감당할 수 있는 만큼만 요청을 보내야 합니다.

문제 상황:

B 서비스는 초당 100개만 처리할 수 있는데, A 서비스가 이벤트를 시작해서 초당 300개를 보냅니다.

B 서비스가 과부하로 느려지고, 결국 B를 호출하는 A 서비스까지 함께 느려집니다.

해결책 (벌크헤드 패턴):

A 서비스에서 B 서비스로 보내는 동시 요청을 100개로 제한합니다.

100개 요청은 B로 정상 전송하고, 나머지 200개는 즉시 실패 처리 (e.g., 503 오류 응답)합니다.

결론: 일부 사용자는 실패하지만, A 서비스와 B 서비스 전체가 마비되는 최악의 상황은 막을 수 있습니다.

4. 서킷 브레이커 (Circuit Breaker): 고장 난 곳은 잠시 차단
   '전기 차단기'처럼, 외부 서비스가 명백히 고장 났다고 판단되면 더 이상 요청을 보내지 않고 즉시 차단합니다.

왜 필요한가?

B 서비스가 다운됐는데, 타임아웃(5초)이 발생할 때까지 기다리는 것은 자원 낭비입니다.

다운된 B 서비스에 계속 요청을 보내는 것은 B의 복구를 방해하는 '공격'이 될 수 있습니다.

작동 방식 (3가지 상태):

Closed (닫힘): (정상 상태) 요청을 B로 전달하며 실패율을 감시합니다. (예: "10초간 50% 실패")

Open (열림): (장애 상태) 실패율이 임계치를 넘으면, 요청을 B로 보내지 않고 즉시 실패시킵니다. (Fast Fail) 일정 시간(예: 1분) 동안 이 상태를 유지합니다.

Half-Open (반 열림): 1분이 지나면, 테스트 요청을 1~2개만 B로 보내봅니다.

성공 시 → Closed (정상 복귀)

실패 시 → Open (다시 차단)

5. DB와 외부 연동: 트랜잭션을 조심하라
   DB 작업(트랜잭션) 중에 외부 API를 호출하는 것은 매우 위험합니다.

문제 상황 1 (DB 커넥션 풀 고갈):

DB 커넥션 획득 → 1. DB 조회 (0.1초) → 2. 외부 API 호출 (4.8초) → 3. DB 저장 (0.1초) → DB 커넥션 반납

위 로직에서 DB는 0.2초만 일하지만, DB 커넥션은 5초 내내 점유됩니다.

만약 DB 커넥션 풀이 10개인데, 이런 요청이 10개만 동시에 들어오면, DB 커넥션 풀이 꽉 차서 다른 모든 DB 작업이 중단됩니다.

결론: 외부 API가 느려졌다는 이유만으로 DB가 빠른데도 서비스 전체가 마비됩니다.

해결책:

외부 API 호출을 DB 트랜잭션 밖에서 하세요.

(Good) 1. 외부 API 호출 → 2. DB 트랜잭션 시작 & 저장 → 3. 커밋

(Good) 1. DB 트랜잭션 시작 & 저장 → 2. 커밋 → 3. 외부 API 호출

문제 상황 2 (데이터 불일치):

1. 외부 API 호출 (포인트 차감 성공) → 2. DB 저장 (주문 내역 저장 실패) → 3. 트랜잭션 롤백

결과: 주문은 안 됐는데, 포인트만 차감됐습니다.

해결책: DB 롤백 시, '포인트 차감 취소 API'를 반드시 호출해야 합니다. (보상 트랜잭션)

6. HTTP 커넥션 풀: 연결 시간 아끼기
   DB 커넥션 풀처럼, 외부 API를 호출할 때도 이미 맺어진 HTTP 연결을 재사용합니다.

이유: 매번 새로 연결(TCP/SSL Handshake)하는 비용은 비쌉니다.

고려사항:

풀 크기: 너무 크면 외부 서비스에 과부하를 줍니다. (3번 동시 요청 제한과 연관)

Keep-Alive 시간: 외부 서버가 "이 연결은 30초만 유지함"이라고 했는데, 내가 60초 뒤에 쓰려 하면 오류가 납니다. 서버 설정보다 짧게 잡아야 합니다.

7. 이중화 (Redundancy): 한 곳이 죽어도 괜찮도록
   가장 중요하고 핵심적인 외부 연동(결제, 본인인증 등)은 여러 업체를 계약해서 사용합니다.

예시: A사 PG(결제)가 장애 나면, B사 PG로 자동 전환하여 결제를 계속합니다.

단점: 개발비와 계약비가 2배로 듭니다.

결정 기준: "이 기능이 멈췄을 때 발생하는 손실"이 "이중화 비용"보다 큰지 따져봐야 합니다.