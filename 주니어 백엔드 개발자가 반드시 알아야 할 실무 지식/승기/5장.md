## 5장: 비동기 연동, 언제 어떻게 써야 할까


### 1. 비동기 연동

- **동기 방식**: 순차 실행, 한 작업이 끝날 때까지 다음 작업 진행되지 않음.
- **비동기 방식**: 한 작업이 끝날 때까지 기다리지 않고 다음 작업 처리, 외부 연동 시 비동기 방식 채택하여 전체 서비스 처리량과 응답 시간 개선 기대
- **비동기 방식으로 연동해도 크게 문제가 되지 않는 케이스**:
    - 동기 호출보다 약간의 지연(시차)이 허용되는 경우
    - 일부 기능 실패 시 재시도하거나 수동 처리 가능할 때
    - 무시해도 되는 기능일 때

### 2. 별도 스레드를 이용한 비동기 연동 

- 기존 스레드와 분리해 **새로운 스레드 생성**하여 비동기 처리
- **쓰레드 풀** 활용: 자원 재사용과 관리 편리
- 프레임워크가 제공하는 비동기 기능 사용
    - 스프링: @Async 어노테이션, 메서드 명에 비동기 실행과 관련된 단어 추가하는 것이 좋음
- 스레드와 메모리
    - 스레드는 프로세스의 힙 메모리를 공유하므로, 공유 객체를 동시에 수정할 때 동시성 문제가 발생할 수 있어 락, 불변 객체, 메시지 전달 방식 등을 고려해야 한다.​
    - 스레드를 많이 만들면 컨텍스트 스위칭 비용과 스택 메모리 사용량이 늘어나기 때문에, 보통 스레드 풀을 사용해 개수를 제한하고 재사용한다.​

### 3. 메시징을 이용한 비동기 연동

- **메시징 시스템**은 연동이 필요한 두 시스템 사이 위치
- 메시징 시스템의 이점:
    - 생산자(Producer)-소비자(Consumer) 구조 통해 **처리량 확장 용이**
    - 메시지는 **큐에 쌓여 비동기 처리**되며, **시스템 간 독립적 연결 보장**(두 시스템이 서로 영향 주지 않음)
- 생산자/소비자, 게시자/구독자
    - **생산자-소비자** 구조: 큐를 중심으로 한 1:N, N:M 비동기 처리 패턴
    - **게시자–구독자(Pub/Sub)** 구조: 특정 토픽에 발행(Publish)하면 구독(Subscribe) 중인 여러 소비자가 메시지를 받는 방식
- 메시징 시스템 기술 별 특징과 장단점
    - **카프카**: 대용량 로그·이벤트 스트림 처리에 최적화(높은 처리량), 파티션 기반 순서 보장과 수평 확장, 메시지 재처리/재생에 강함(디스크 저장으로 유실 없음), 풀 모델(소비자가 브로커에서 직접 읽음)로 소비자별 처리 속도 독립적.
    - **래빗MQ**: 라우팅, 지연 큐, 다양한 패턴, 프로토콜 지원에 유연한 범용 메시지 큐, 푸시 모델(브로커가 소비자에게 메시지 전달), 메시지 전달 확인 기능 제공, 클러스터로 처리량 확장 가능하지만 카프카보다 자원 소모 많음, 장애 시 메시지 유실 가능성 존재, 소비자 성능 저하 시 큐 과부하로 전체 시스템 영향.
    - **Redis Pub/Sub**: 실시간 알림·브로드캐스트에 최적화된 초경량 솔루션, 설정/운영 간단, 메모리 기반으로 지연시간 짧으나 처리량은 제한적이지만 래빗MQ보다 우수, 메시지 유실 보장 없음(구독자 없으면 즉시 삭제, 영구 저장 X), 비영속적 특성으로 신뢰도 낮은 용도에 적합.
    - 특정 기술은 “유행”을 타지만, 실제로는 팀 경험, 운영 난이도에 따라 선택하는 것이 중요하다.
- 메시지 생성 측 고려 사항
    - 무시한다: 비즈니스적으로 실패해도 큰 문제가 없는 방식(알림, 로그 전송 등), 가장 단순하지만 신뢰도 낮음.
    - 재시도한다: 일정 횟수 재시도 처리, 멱등성 보장 필수(중복 메시지로 데이터 꼬임 방지).
    - 실패 로그 남긴다: 실패 시 실패 로그 테이블/파일에 기록해 나중에 수동/자동 재처리.
- 메시지 소비 측 고려 사항
    - 메시지 중복 수신을 가정하고, 같은 메시지를 여러 번 받아도 비즈니스가 꼬이지 않도록 메시지에 고유 ID를 부여하고, 멱등 처리를 해야 함.
- 메시지 종류: 이벤트와 커맨드
    - **이벤트(Event)**: “어떤 일이 발생했음”을 알리는 메시지로, 발행자는 “어떻게 사용할지”를 모르는 상태에서 전달.​
    - **커맨드(Command)**: “무언가를 해달라”는 명령으로, 수신자의 행동을 의도한 메시지이며, 보통 대상이 명확한 1:1 또는 N:1이다.
    - 궁극적 일관성(Eventual Consistency): 분산 시스템에서는 모든 서비스의 상태가 즉시 일치하지 않고, 시간이 지나면서 메시지 처리·동기화를 통해 최종적으로 일관된 상태에 수렴하는 모델을 사용. 비동기 메시징 방식도 유사.

### 4. 트랜잭션 아웃박스 패턴

- 하나의 DB 트랜잭셔 내에서 2가지 작업 수행
    1. 실제 업무 로직에 필요한 DB 변경 작업 수행
    2. 메시지 데이터를 아웃박스 테이블에 추가
- DB 트랜잭션과 메시지 전송 원자성 보장
- DB에 비즈니스 데이터와 함께 “보낼 메시지”도 같은 트랜잭션 내에서 아웃박스 테이블에 기록하고, 이후 별도 메시지 중계 프로세스가 아웃박스 읽어 메시지 브로커로 발행하는 패턴
- 아웃박스 테이블 구조 
    - 메시지 ID, 타입, 페이로드, 생성 시간, 상태(대기/완료/실패), 실패 횟수 등

### 5. 배치 전송

- 데이터를 비동기로 연동하는 가장 전통적인 방법, 실시간 대신 일정 주기(예: 5분/1시간/하루 등)로 데이터를 모아 한 번에 연동하는 방식 
    - 예: 정산, 통계, 대량 보고용 파일 전송(FTP/SFTP/HTTP 등).
- 배치 전송 실행 과정
    1. DB에서 전송할 데이터 조회
    2. 조회 결과 파일 기록
    3. 연동 시스템에 파일 전송 (FTP/SFTP, SCP)
- 재처리 기능 만들기
    - 네트워크·상대 시스템 문제로 특정 배치 실행이 실패할 수 있으므로, “다시 보낼 수 있는 구조”가 중요


### 6. CDC

- CDC(Change Data Capture)를 통해 데이터 변경 이벤트 기반 비동기 처리 가능.
- DB의 변경 로그를 읽어 데이터 변경을 감지하고, 이를 기반으로 이벤트를 생성해 다른 시스템에 전달하는 방식.
- CDC가 유용할 때:
    - 기존 레거시 시스템 DB에 코드를 크게 손대기 어렵지만, 변경 내용을 다른 시스템으로 흘려보내야 할 때.​