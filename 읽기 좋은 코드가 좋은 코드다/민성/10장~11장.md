# 10장: 상관없는 하위문제 추출하기 정리

## 📍 핵심 아이디어

**엔지니어링의 원리를 코드에 적용하라**

> 큰 문제를 작은 문제들로 쪼개고, 각각의 해결책을 구한 다음 하나의 해결책으로 맞추는 과정
>

**목적과 직접 관련 없는 하위문제를 적극적으로 추출하라**

## 🔍 하위문제 추출 과정 (3단계)

1. **상위수준 목적 파악**
    - "상위수준에서 본 이 코드의 목적은 무엇인가?"
2. **각 줄 검토**
    - "이 코드는 직접적으로 목적을 위해 존재하는가?"
    - "목적을 위해 필요하지만 목적 자체와 직접 관련없는 하위문제를 해결하는가?"
3. **추출 결정**
    - 상당한 분량의 관련없는 하위문제 코드가 있다면 별도 함수로 추출

   
## 하위문제 추출의 장점

### 1. **코드 가독성 향상**

- 메인 로직에 집중 가능
- 복잡한 세부사항에 방해받지 않음

### 2. **재사용성**

- 다른 프로젝트에서도 활용 가능
- 유틸리티 라이브러리 구축

### 3. **테스트 용이성**

- 독립적인 함수는 단위 테스트가 쉬움
- 디버깅이 간편함

### 4. **개선 용이성**

- 작은 함수는 기능 추가나 수정이 쉬움
- 코너케이스 처리가 상대적으로 간단

### 5. **코드베이스 크기 감소**

- 프로그래머가 생각해야 할 내용 감소
- 전체적인 복잡도 관리


# 11장: 한 번에 하나씩 정리

## 📍 핵심 아이디어

> 한 번에 하나의 작업만 수행하게 코드를 구성해야 한다
>

**코드 '탈파편화(defragmenting)' 과정:**

- 여러 작업이 뒤섞인 코드 → 한 번에 한 가지 작업만 수행하는 코드로 재구성

## 🔄 탈파편화 과정 (2단계)

1. **모든 작업 나열**
   - 코드가 수행하는 모든 '작업'을 식별
   - "객체가 정상적으로 존재하는지 확인" (작은 작업)
   - "트리 안의 모든 노드 방문" (큰 작업)
2. **작업 분리**
   - 서로 다른 함수로 분리하거나
   - 최소한 논리적으로 구분되는 영역으로 배치
   
## 📊 작업 분리의 장점

### 1. **가독성 향상**

- 각 영역을 읽을 때 다른 영역을 생각할 필요 없음
- 코드의 흐름이 논리적으로 구성됨

### 2. **디버깅 용이성**

- 특정 작업에 문제가 있을 때 해당 영역만 집중 가능
- 버그 추적이 간단해짐

### 3. **유지보수성**

- 특정 작업의 로직 변경이 다른 부분에 영향 주지 않음
- 코드 수정 범위가 명확해짐

### 4. **테스트 편의성**

- 각 작업을 독립적으로 테스트 가능
- 단위 테스트 작성이 쉬워짐
