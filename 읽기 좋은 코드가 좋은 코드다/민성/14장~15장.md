## 14장: 테스트와 가독성


### 1. 테스트 가독성의 이점

- **신속한 버그 진단**: 실패한 테스트를 빠르게 이해 가능
- **새 기능 개발 가속**: 기존 테스트 패턴을 쉽게 복사해서 확장
- **리팩토링 자신감**: 코드 변경 시 테스트가 안전망 역할

### 2. 미니 랭귀지 활용의 이점

```jsx
*// Before: 10줄의 복잡한 설정 코드// After: 1줄로 테스트 의도 명확 표현*
CheckScoresBeforeAfter("1, 2, -1, 3", "3, 2, 1");
```

- **테스트 작성 시간 90% 단축**
- **테스트 의도 한눈에 파악**

### 3. 좋은 에러 메시지의 이점

```jsx
*// 개선된 에러 메시지로 디버깅 시간 대폭 단축*
Input: "1, 2, -1, 3"
Expected: "3, 2, 1"
Actual: "2, 1, -1"  *// 음수 필터링 버그 즉시 발견*
```

---

## 15장: 분/시간 카운터 설계


### 1. 단계적 접근의 이점

### **1단계 - 순진한 해결책: "일단 돌아가게"**

- 30분 만에 동작하는 코드 완성
- 요구사항이 맞는지 빠르게 확인
- 동료들과 구체적으로 소통 가능
- **한계**: 메모리 무제한 증가로 실운영 불가

### **2단계 - 컨베이어 벨트: "성능 문제 해결"**

- 수백만 이벤트도 즉시 응답하는 O(1) 성능 달성
- 메모리 누수 방지로 실제 서비스 가능
- **한계**: 새 시간 간격 추가 시 전체 코드 수정 필요

### **3단계 - 시간-바구니: "완벽한 해결책"**

- 메모리 사용량 완전 예측 가능 (500바이트 고정)
- 새 기능 1줄로 추가 가능한 확장성
- 다른 프로젝트에서도 재사용 가능
- **트레이드오프**: 코드가 좀 더 복잡해짐

### 2. 최종 해결책의 핵심 이점

```jsx
*// 메모리 사용량: 고정 ~500바이트 (vs 무제한 증가)// 성능: O(1) 시간 복잡도// 유연성: 다양한 시간 간격 쉽게 지원*
class MinuteHourCounter {
    TrailingBucketCounter minute_counts;  *// 재사용 가능한 구조*
    TrailingBucketCounter hour_counts;
};
```

### 3. 클래스 분리 설계의 이점

- **단일 책임 원칙**: 각 클래스가 명확한 역할
- **재사용성**: `TrailingBucketCounter`로 다양한 시간 간격 처리
- **확장성**: 일간/주간/월간 카운터 쉽게 추가 가능

---

## 결론

이번 주차에서는 완벽한 해결책을 처음부터 만들려 하지 말고, 간단한 것부터 시작해서 문제점을 하나씩 해결해 나가며 점진적으로 발전시켜야 한다는 것을 학습했습니다. 또한 읽기 쉬운 코드가 생산성과 유지보수성을 좌우하기 때문에, 복잡함보다는 단순함과 명확함을 우선시해야 한다는 원칙을 깨달았습니다. 좋은 코드는 처음 작성할 때 완성되는 것이 아니라 반복적인 개선을 통해 만들어진다는 핵심을 이해하게 되었고, 이러한 방법을 활용하여 개발 해야 겠다는걸 알게 되었습니다.
