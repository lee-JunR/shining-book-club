
# 읽기 좋은 코드가 좋은 코드다 -  4부 14장, 15장 요약

---

## 14장: 테스트와 가독성

---

- 테스트 코드가 **읽기 쉽고 간결해야** 실제 코드의 동작을 쉽게 이해할 수 있고, 다른 사람이 테스트를 추가/수정하기도 편하다.
- 테스트가 복잡하고 중요하지 않은 세부 내용에 가려져 있으면, 코드 수정이나 새로운 테스트 추가가 어려워지고, 테스트를 회피하게 된다.
- **좋은 테스트 작성법**
    - 테스트의 핵심 입력/출력을 한 줄로 요약할 수 있도록 필요한 작업만  단순하게 표현한다.
    - 중복되는 설정이나 반복적인 값은 헬퍼 함수로 감춰 필요한 정보만 드러나게 한다.
    - 테스트 실패 시에는 **입력값, 실제 결과, 기대 결과**를 명확히 보여주는 에러 메시지를 출력한다.
    - 입력값은 복잡한 값보다 **가장 간단하면서도 코드를 충분히 검사할 수 있는 값으로** 선정한다.
    - 각 테스트 함수에는 테스트 대상 함수와 상황을 명확히 설명하는 구체적인 이름을 붙여야 한다.
- 테스트하기 좋은 코드는
    - 내부 상태가 적고, 독립적이며, 인터페이스가 단순하다.
    - 외부 컴포넌트나 전역변수 등 복잡한 초기화가 필요하지 않다.
- 테스트에 너무 집착하거나, 실제 코드의 가독성을 희생하면서까지 테스트를 위한 구조를 강요하는 것은 바람직하지 않다.
- 테스트의 가독성을 높이면 테스트 추가/유지보수가 쉬워지고,  
  실제 코드의 설계 역시 자연스럽게 더 좋아진다.


---

## 15장: 분/시간 카운터 설계하고 구현하기

---

- 실제 현장 코드에서 쓰이는 ‘분/시간 카운터’ 데이터 구조를 단계별로 설계하고 구현하는 과정

1. **초기 설계: 클래스 인터페이스 정의**  
   - `MinuteHourCounter` 클래스는 1분간과 1시간간의 누적 카운트를 제공한다.
   - 메서드 이름과 주석을 명확하고 직관적으로 다듬었다.  
   - 예: `Add(int count)` → ‘count’ 값만큼 더한다는 의미로 명확하게 수정.

2. **순진한 해결책 (초기 구현)**  
   - 이벤트를 시간과 함께 리스트에 저장하고, 최근 1분과 1시간 이내의 값만 계산한다.  
   - 정확하나 성능이 매우 느리고 메모리 사용량이 계속 증가한다.

3. **컨베이어 벨트 설계 (두 번째 시도)**  
   - 두 개의 리스트(1분, 1시간)로 이벤트를 ‘이동’시키며 오래된 데이터를 제거한다.  
   - 이전보다 빠르고 메모리 효율이 좋아졌지만, 여전히 1시간 외 다른 시간대를 다루기엔 유연성이 부족하다.

4. **시간-바구니 설계 (최종 시도)**  
   - 지난 N개의 고정된 시간 구간을 ‘바구니’로 나누어 관리한다.  
   - 각 바구니에 해당 시간대의 이벤트를 집계하여, 메모리 사용량과 계산 비용을 일정하게 유지할 수 있다.  
   - 시간 단위가 명확해 정확도도 보장하고, 유연성도 향상되었다.

5. **계층적 클래스 구조**  
   - `ConveyorQueue`: 고정된 크기의 큐로 오래된 데이터를 제거하며, 총합을 관리.  
   - `TrailingBucketCounter`: `ConveyorQueue`를 이용해 시간 흐름에 따른 카운트 유지.  
   - `MinuteHourCounter`: 두 개의 `TrailingBucketCounter`를 갖고 분/시간 단위 카운팅 제공.

---

## 핵심 요약

- **테스트 코드는 코드 자체만큼이나 중요하며, 가독성과 의도 설명에 집중해야 한다.**
- **점진적으로 개선해 나가는 설계 과정이 매우 중요하다.**  