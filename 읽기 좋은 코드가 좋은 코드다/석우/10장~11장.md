# 10장 ~ 11장 정리

## 10장 상관없는 하위문제 추출하기

- 순수한 유틸리티 코드
- 일반적인 목적의 코드
- 일반적인 목적을 가진 코드를 많이 만들어라
- 특정한 프로젝트를 위한 기능
- 기존의 인터페이스를 단순화하기
- 자신의 필요에 맞춰서 인터페이스의 형태를 바꾸기
- 지나치게 추출하기

### **상관없는 하위문제 추출하기 정리**

10장 내용에서는 큰 문제를 작은 문제로 쪼개고 그중에서 전체 목적과 직접 관련 없는 하위문제를 별도의 함수로 분리하는 것이라고 이야기하고 있습니다.

하위문제를 추출하는 방법으로는 코드의 목적을 파악하고 하위문제를 식별하여 함수로 추출하는데 추출된 함수(하위문제)가 자신이 호출되는 이유 상위 코드의 맥락을 몰라야 한다는 것입니다.

추출된 하위 함수는 상위 코드의 맥락을 몰라야 한다 이 원칙은 높은 응집도와 낮은 결합도라는 좋은 코드의 특징을 구현하기 위한 핵심 전략이라고 생각합니다.

그래야 하나의 함수가 하나의 기능만 잘 수행하며 상위 코드와 하위 코드 간의 의존성이 낮아져 한쪽을 수정해도 다른 쪽에 영향을 주지 않는 코드를 작성하게 됩니다.

위 방식을 적용하면 코드의 견고함과 가독성을 동시에 높이는 효과적인 방법이라고 생각이 됩니다.

```java
// 모든 로직이 한 함수에 섞임
void greetUser(String name) {
    // 이름이 null이거나 비었는지 확인
    if (name == null || name.trim().isEmpty()) {
        System.out.println("이름이 없습니다.");
        return;
    }

    // 대문자로 변환
    String upperName = name.toUpperCase();

    // 인사 출력
    System.out.println("안녕하세요, " + upperName + "님!");
}

// 하위 문제를 함수로 분리
void greetUser(String name) {
    if (!isValidName(name)) {
        System.out.println("이름이 없습니다.");
        return;
    }
    System.out.println("안녕하세요, " + formatName(name) + "님!");
}

boolean isValidName(String name) {
    return name != null && !name.trim().isEmpty();
}

String formatName(String name) {
    return name.toUpperCase();
}
```

## 11장 한 번에 하나씩

- 작업은 작을 수 있다
- 객체에서 값 추출하기
- 더 큰 예제

1. 현재 코드가 하는 모든 작업 나열
2. 작업별로 그룹화
3. 작업을 분리
4. 각 작업이 서로 독립적으로 만들기

### **한 번에 하나씩 정리**

11장에서는 코드가 한 번에 하나의 작업만 수행하도록 재구성하는 것인데 여러 가지 작업이 뒤섞여 있는 코드는 이해하기 어렵고 오류를 찾기 힘들다는 내용으로 코드를 논리적인 작업 단위로 탈파편화하면 가독성과 유지보수성이 향상된다고 말하고 있다.

한 번에 하나씩 코드를 구성하는 방법으로는 현재 코드가 수행하는 모든 작업을 상세하게 나열하며 나열된 작업들을 서로 분리하여 별도의 함수로 만들거나 최소한 원래 함수 내에서 논리적으로 구분되는 영역(코드 블록)으로 재정렬하는 방법입니다.

반드시 함수 단위로만 적용되는 것은 아니며 거대한 함수라고 가정하면 그 함수 내에서도 코드를 논리적 단락으로 나누는 것만으로도 코드를 이해하는데 도움이 된다고 생각합니다.

#### 결론

> 복잡한 문제를 다룰 때는 관련 없는 하위 문제는 밖으로 빼고 남은 코드도 작업별로 나누어 한 번에 하나씩 처리하면 코드가 더 직관적으로 읽히고 수정 시 다른 부분에 미치는 영향이 줄어든다 결국 이는 좋은 코드의 가장 중요한 특징인 다른 사람이 이해하기 쉬운 코드를 작성하는데 중요한 요소라고 생각합니다.
