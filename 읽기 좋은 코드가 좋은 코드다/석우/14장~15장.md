# 14장 ~ 15장 정리

## 14장 테스트와 가독성

- 읽거나 유지보수하기 쉽게 테스트를 만들어라
- 이 테스트는 어떤 점이 잘못되었을까?
- 이 테스트를 더 읽기 쉽게 만들기
- 읽기 편한 메시지 만들기
- 좋은 테스트 입력값의 선택
- 테스트 함수에 이름 붙이기
- 이 테스트 코드는 무엇이 잘못되었는가?
- 테스트에 친숙한 개발
- 지나친 테스트

### **테스트와 가독성 정리**

테스트 코드 역시 실제 코드와 마찬가지로 가독성이 중요하다. 잘 작성된 테스트는 다른 개발자가 코드의 사용법과 동작을 이해하는 비공식 문서 역할을 할 수 있기 때문에, 짧고 단순하며 추가·수정이 쉬워야 한다. 그러나 흔히 테스트 코드에는 불필요한 세부 구현이나 의미 없는 값, 복잡한 입력값이 많아 읽기 어렵고, 실패 메시지가 부족하며 여러 기능을 한 번에 검증하는 문제가 발생한다. 이를 개선하기 위해서는 헬퍼 함수를 활용해 불필요한 세부사항을 숨기고 핵심만 드러내며, 테스트를 “입력 → 기대 결과” 형태로 간결히 표현해야 한다.

좋은 테스트 입력값은 간단하면서도 코드의 다양한 분기와 예외 상황을 실행할 수 있어야 한다. 따라서 불필요하게 복잡한 값은 피하고, 중복·음수·0·빈 입력 등 엣지 케이스를 포함하는 것이 이상적이다. 테스트 함수 이름도 Test1()과 같이 의미 없는 형식이 아니라, Test*<함수명>*<상황>과 같이 테스트 목적을 드러내는 이름을 붙여야 한다.

나쁜 테스트의 특징은 지나치게 길고 불필요한 세부사항이 많으며, 새로운 테스트 추가가 어렵고 실패 메시지가 불친절하다는 것이다. 또한 여러 기능을 동시에 검증하거나 불필요하게 복잡한 입력값을 사용하고, 특수한 케이스나 비정상 입력을 고려하지 않는 것도 문제다.

테스트하기 쉬운 코드는 잘 정의된 인터페이스, 적은 상태값, 최소한의 의존성을 가진 코드는 자연스럽게 모듈화가 가능하고, 테스트 친화적인 설계를 이끈다. 하지만 테스트에 지나치게 집착해서는 안 된다. 테스트를 위해 본래 코드의 가독성을 희생하거나 100% 커버리지를 목표로 삼는 것은 오히려 비효율적이다. 또한 사소한 UI나 특수한 상황까지 과도하게 테스트하거나, 테스트 작성 자체가 개발의 목적을 압도하는 경우도 피해야 한다. 결국 테스트는 비용과 안정성의 균형 속에서 맥락에 맞게 작성하는 것이 가장 중요하다.

## 15장 분/시간 카운터를 설계하고 구현하기

- 문제
- 클래스 인터페이스 정의하기
- 시도1: 순진한 해결책
- 시도2: 컨베이어 벨트 설계
- 시도3: 시간-바구니 설계
- 3가지 해결책 비교하기

### **분/시간 카운터를 설계하고 구현하기 정리**

분/시간 카운터 문제는 지난 1분과 1시간 동안 서버가 보낸 바이트 수를 추적한다는 단순한 요구사항에서 출발한다. 처음에는 모든 이벤트를 시간과 함께 리스트에 저장하고 필요할 때마다 최근 이벤트를 순회하는 방식으로 구현할 수 있다. 하지만 이 방법은 이해는 쉽지만 코드 중복이 많고, 메모리 사용량이 무한히 증가하며 성능이 나쁘다는 단점이 있다.

이를 개선하기 위해 두 번째 시도로 컨베이어 벨트 설계를 적용했다. 분 단위와 시간 단위 리스트를 각각 유지하면서, 데이터를 양쪽 끝에서 추가·삭제하고 합계를 미리 계산해 두어 성능 문제를 해결한 것이다. 그러나 이 방식은 여전히 메모리 소모가 크고, 새로운 시간 단위를 지원하려면 코드 수정이 불가피하다는 한계가 있었다.

세 번째 시도에서는 데이터를 일정한 크기의 시간-바구니(bucket) 단위로 집계하는 설계를 도입했다. 각 바구니는 60초 또는 60분 동안의 합계를 저장하며, 고정된 개수의 바구니만 유지하기 때문에 메모리 사용량이 일정하고 예측 가능하다. 이 방식은 성능이 뛰어나고 다양한 시간 범위로 쉽게 확장할 수 있으며, 코드의 재사용성과 가독성도 높아졌다.

세 가지 해결책을 비교하면, 첫 번째 방식은 단순하지만 성능과 메모리 문제가 치명적이고, 두 번째 방식은 성능은 개선했으나 여전히 메모리와 확장성에서 부족하다. 반면, 시간-바구니 설계는 코드가 조금 길어지더라도 성능, 유연성, 가독성을 모두 갖춘 가장 실용적인 해결책임을 알 수 있었다.

#### 결론

두 장의 교훈은, 좋은 코드란 읽기 쉽고 유지보수하기 쉬운 코드이며, 단순한 문제라도 다양한 시도를 통해 더 나은 설계를 찾을 수 있다는 것이다. 즉, 테스트와 설계 모두 짧고 단순하면서도 확장성과 가독성을 고려한 균형 잡힌 접근이 핵심 원칙임을 알 수 있었다.
